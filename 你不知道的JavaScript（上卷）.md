作用域和闭包
第一章作用域是什么
在“非严格模式”下运行，当变量还没有声明时，如果在全局作用域中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量。
第二章词法作用域
遮蔽效应（内部的标识符“遮蔽”了外部的标识符）：作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

JavaScript 中的 eval(..) 函数可以接受一个字符串为参数
默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对 eval(..) 所处的词法作用域进行修改

在严格模式的程序中， eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。在严格模式下，with被完全禁止。

第3章：函数作用域和块作用域
函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。

区分函数声明和函数表达式

匿名函数和具名函数

立即执行函数表达式

let：变量声明方式 可以将变量绑定到所在的任意作用域中

第四章：提升
函数声明会被提升，但函数表达式不会
函数声明和变量声明都会被提升。但函数会首先被提升，然后才是变量

第五章：闭包
当函数可以记住并访问所在的词法作用域时，就产生了闭包

闭包可以阻止垃圾回收器对函数回收

模块模式需要具备两个必要条件
1. 必须有外部的封闭函数，该函数必须至少被调用一次
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态

模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。
